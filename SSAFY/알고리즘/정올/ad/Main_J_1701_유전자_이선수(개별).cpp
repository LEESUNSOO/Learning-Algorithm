/*
	주어진 문자열내에서 KOI가 해당하는 최대 길이를 구하는 경우라면 순회를 통해 가능하지만
	이 문제에서 길이 내에서 특정 문자를 제거도 가능했다.
	제거함에 따라 KOI가 안되던 문자열도 가능해지기 때문에 모든 길이의 순서를 지키는
	문자열 조합을 구해본다고 생각하면,

	1. DNA 서열의 최대 길이가 500자다
	 - 만약, 길이가 1개, 2개, ... , 500개
	 최대 길이의 경우, nCr = n!/(r!/(n-r)!) ex 5C2 = 5! / (2!(5-2)!) = 10
	 - 1개 일때, 500가지,
	 - 2개 일때, 500C2,
	 -  ,,, 
	 - 499(n-1)개 일때, 500C499
	 - 500(n)개 일때, 500C500
	 => 500 + 500!/(2!498!) + .... + !
	 상당히 많은 경우의 수가 존재하므로 재귀를 활용한 조합을 구하는 건 잘못된 방법이다.
	 2. DP를 활용하는 방법(개인적으로 재귀로 보이는데 시간 촉박해보이는 건 보통 DP였다.)
	 ABCDE 라는 문자열이 있다고 생각해보자.
	 KOI를 이루려면 최소 길이는 2이기 때문에 앞에서부터 두개의 문자열부터 진행한다.
	 이때, KOI유전자가 존재하지 않는 경우, 0을 출력하기 때문에 DP배열은 0으로 초기화한다.
	 1) AB 검사
	  - AB의 첫문자와 끝문자가 KOI조건에 해당하면 
	  DP[첫문자열인덱스][끝문자열인덱스] = DP[첫문자열인덱스+1][끝문자열인덱스-1]+2 를 해준다.
	  인덱스의 변화는 내부 문자열의 DP값을 뜻하고, 현재 두 문자의 길이인 2를 추가해주는 것이다.
	  앞에서부터 순차적으로 진행하기 때문에 내부의 문자열도 KOI를 이루고 있다면 문제없다.
	  accct의 경우에도 axxxt가 조건에 해당하는거 같지만 사실상, aXt일때 X가 KOI여야만 KOI로
	  인정되기떄문에 (조건 2) ccc문자열의 DP값 0과 +2, 결과적으로 2라는 값을 갖게 되고
	  이때, 의미하는바는 ccc를 삭제시킨 경우를 의미한다.
	 2) 이후, 3개이상의 문자열을 검사하는 경우, DP의 맥스값을 정해야한다.
	  - 이때, (조건 3) KOI+KOI인 경우를 검사하는 것이다.
		for(int i = 현재 검사기준 인덱스 ; i < 문자열길이 ; i++)
		{
			for(int j = i-1; j >=1 ; j--) // i의 이하로 범위를 넓혀가며 검사
			{
				if(...) // KOI 조건 검사 (a,t), (c,g) 앞 뒤 검사
				true => 내부DP + 2;

				/////////////////// => 이때, (조건 3)에 맞는 최대값 비교를 진행한다
				for(int k = 1; k <= j-i; k++) // 시작점과 끝점사이의 부분 DP를 비교하는 부분 j-i = 길이
				{
									  이분할 앞부분 이분할 뒷부분
					int divideDpSum = DP[j][i-k] + DP[i-k+1][i]
					===================================================
					ex)i = 4, j = 1
					k(1~3)		
							k = 1		 1   3          4    4	□ □ □ ■
							k = 2		 1   2          3    4	□ □ ■ ■
							k = 3		 1   1          2    4	□ ■ ■ ■
					===================================================

					if(DP[i][j] < divideDpSum)
						DP[i][j] = divideDpSum;
				}
			}
		}
		return DP[1][N]; // 최종적으로 N번째까지 검사를 마치면 문자열 내에서 최장수열길이가 저장된다.
*/

#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
#define MAX(a,b) (a>b?a:b)

int DP[501][501];
string s;
int gene(int len)
{
	for (int i = 1; i < len; i++)
	{
		for (int j = i - 1; j >= 0; j--)
		{
			string temp = s.substr(j, i - j + 1);
			if ((temp[0] == 'a' && temp[i - j] == 't') || (temp[0] == 'g' && temp[i - j] == 'c'))
			{
				DP[j][i] = DP[j + 1][i - 1] + 2;
			}

			for (int k = 1; k <= i - j; k++)
			{
				int divDpSum = DP[j][i - k] + DP[i - k + 1][i];

				DP[j][i] = MAX(DP[j][i], divDpSum);
			}
		}
	}

	return DP[0][len - 1];
}

int main()
{
	cin >> s;
	//s = "acattgagtc";
	int l = s.length();
	cout << gene(l);
	return 0;
}
